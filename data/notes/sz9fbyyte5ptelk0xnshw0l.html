<h1 id="2023-04-03">2023-04-03<a aria-hidden="true" class="anchor-heading icon-link" href="#2023-04-03"></a></h1>
<h1 id="this-is-maëlles-dbgi-daily-open-notebook">This is Maëlle's DBGI daily open-notebook.<a aria-hidden="true" class="anchor-heading icon-link" href="#this-is-maëlles-dbgi-daily-open-notebook"></a></h1>
<p>Today is 2023.04.03</p>
<h2 id="todo">TODO<a aria-hidden="true" class="anchor-heading icon-link" href="#todo"></a></h2>
<ul>
<li>Check discussion: <a href="https://github.com/orgs/digital-botanical-gardens-initiative/discussions">https://github.com/orgs/digital-botanical-gardens-initiative/discussions</a></li>
<li>Check Zulip</li>
</ul>
<h2 id="code">CODE<a aria-hidden="true" class="anchor-heading icon-link" href="#code"></a></h2>
<h2 id="notes">NOTES<a aria-hidden="true" class="anchor-heading icon-link" href="#notes"></a></h2>
<h2 id="todo-next">TODO NEXT<a aria-hidden="true" class="anchor-heading icon-link" href="#todo-next"></a></h2>
<h2 id="important-for-redaction">Important for redaction<a aria-hidden="true" class="anchor-heading icon-link" href="#important-for-redaction"></a></h2>
<p>Treemaps are a good alternative to sunburst graphs when dealing with large datasets, as they can display hierarchical data more efficiently, especially when there are many items at each level of the hierarchy.</p>
<p>  Optimize the treemap rendering:</p>
<p>  a. If your dataset is very large, you can consider aggregating the data before rendering the treemap. This would reduce the number of nodes, which would improve rendering performance. You can use the groupby() function from pandas to aggregate the data based on specific levels of hierarchy</p>
<pre><code>Optimize the dataset processing:

a. Read only required columns from the CSV file using usecols parameter. You are already doing this, which is good.

b. Instead of filtering the DataFrame twice and filling NaN values, you can filter and fill NaN values in one step using the query() method
</code></pre>
<p>To render better user experience: dcc.loading</p>